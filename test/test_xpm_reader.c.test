
#include "math.h"
#include "stdio.h"
#include "time.h"

#include "../src/wx_math.h"
#include "../src/wx_types.h"
#include "../src/wx_parse_xpm.h"
#include "../src/wx_parse.h"
#include "../src/wx_frame_buffer.h"

# define WX_XPM_FREE_KEY (1)
# define WX_XPM_FREE_KEYWORD (2)
# define WX_WX_XPM_FREE_PIXELS (3)

typedef struct s_color_key
{
	t_u32	color;
	t_u8	*keyword;

}					t_color_key;

typedef struct s_xpmtest
{
	t_u32		width;
	t_u32		height;
	t_u32		color_count;
	t_u32		keyword_length;
	t_color_key	*key;
	t_key_value	*table;
	t_u32		table_size;
	t_u32		*pixels;
}	t_xpmtest;

t_bool	zz_parse_xpm_error(t_xpmtest *xpm, t_u32 error, t_u32 index)
{
	t_u32	i;

	if (error == WX_XPM_FREE_KEY)
		free(xpm->key);
	else if (error == WX_XPM_FREE_KEYWORD)
	{
		i = 0;
		while (i < index + 1)
		{
			free(xpm->key[i].keyword);
			i++;
		}
		free(xpm->key);
	}
	else if (error == WX_WX_XPM_FREE_PIXELS)
	{
		free(xpm->pixels);
		return (zz_parse_xpm_error(xpm, WX_XPM_FREE_KEYWORD,
				xpm->color_count - 1));
	}
	return (wx_false);
}


static t_bool	zz_parse_end_of_line(t_parse_context *pc, t_parse_xpm_index i,
	t_xpmtest *xpm)
{
	if (i.h < xpm->height - 1)
	{
		if (!wx_parse_keyword(pc, "\",\n\""))
			return (zz_parse_xpm_error(xpm,
					WX_WX_XPM_FREE_PIXELS, xpm->color_count - 1));
	}
	else
	{
		if (!wx_parse_keyword(pc, "\""))
			return (zz_parse_xpm_error(xpm,
					WX_WX_XPM_FREE_PIXELS, xpm->color_count - 1));
		wx_parse_whitespace(pc);
		if (!wx_parse_keyword(pc, "};"))
			return (zz_parse_xpm_error(xpm,
					WX_WX_XPM_FREE_PIXELS, xpm->color_count - 1));
		wx_parse_whitespace(pc);
	}
	return (wx_true);
}


static t_bool	zz_is_key(t_parse_context *pc, t_xpmtest *xpm,
t_parse_xpm_index i)
{
	t_u32		keyword_index;

	keyword_index = 0;
	while (pc->p != pc->e && *pc->p == xpm->key[i.key_index].keyword[keyword_index]
		&& keyword_index < xpm->keyword_length)
	{
		if (keyword_index == xpm->keyword_length - 1)
		{
			pc->p++;
			return (wx_true);
		}
		pc->p++;
		keyword_index++;
	}
	pc->p -= keyword_index;
	return (wx_false);
}

/*
** Old version.
** Find the keyword matching the image key and save corresponding color.
** If no keyword matching the key is found, free saved colors and
** previously allocated pixel-array.
*/

t_bool	zz_key_match(t_parse_context *pc, t_xpmtest *xpm,
	t_parse_xpm_index i)
{
	t_u32		color;

	i.key_index = 0;
	while (i.key_index < xpm->color_count)
	{
		if (zz_is_key(pc, xpm, i))
		{
			color = xpm->key[i.key_index].color;
			xpm->pixels[i.pixel_index] = color;
			return (wx_true);
		}
		i.key_index++;
	}
	return (zz_parse_xpm_error(xpm,
			WX_WX_XPM_FREE_PIXELS, xpm->color_count - 1));
}

/*
** Old version.
** Parse comment, allocate pixel-array. Free saved colors upon failure.
** Loop through xpm image comparing pixel keys to color keywords.
** Free saved colors and previously allocated pixel-array upon failure.
*/

t_bool	zz_parse_xpm_pixels(t_xpmtest *xpm, t_parse_context *pc)
{
	t_u32				size;
	t_parse_xpm_index	i;

	size = xpm->height * xpm->width * sizeof(t_u32);
	xpm->pixels = (t_u32 *)malloc(size);
	if (!wx_parse_keyword(pc, "\"") || !xpm->pixels)
		return (zz_parse_xpm_error(xpm,
				WX_XPM_FREE_KEYWORD, (xpm->color_count - 1)));
	i.pixel_index = 0;
	i.h = 0;
	while (i.h < xpm->height)
	{
		i.w = 0;
		while (i.w < xpm->width && pc->p != pc->e)
		{
			if (!zz_key_match(pc, xpm, i))
				return (wx_false);
			i.pixel_index++;
			i.w++;
		}
		if (!zz_parse_end_of_line(pc, i, xpm))
			return (wx_false);
		i.h++;
	}
	return (wx_true);
}

static t_bool	zz_parse_hexa(t_parse_context *pc, t_u32 *hex)
{
	t_u8	numbers[6];
	t_u32	i;

	i = 0;
	while (i < 6 && pc->p != pc->e)
	{
		numbers[i] = *pc->p;
		i++;
		pc->p++;
	}
	if (!wx_parse_hex(numbers, hex, 6))
		return (wx_false);
	return (wx_true);
}

/*
** Old version.
** Parse possible comment. If line doesn't start with ", free colors' array.
** Parse color keys and corresponding colors and save them. Parse comment.
** Free allocated colors upon failure.
*/

t_bool	zz_parse_xpm_colors(t_xpmtest *xpm, t_parse_context *pc)
{
	t_u32	i;

	i = 0;
	wx_parse_xpm_comment(pc);
	if (!wx_parse_keyword(pc, "\""))
		return (zz_parse_xpm_error(xpm, WX_XPM_FREE_KEY, i));
	while (i <= xpm->color_count - 1 && pc->p != pc->e)
	{
		xpm->key[i].keyword
			= (t_u8 *)malloc(sizeof(t_u8) * xpm->keyword_length);
		if (!xpm->key[i].keyword)
			return (zz_parse_xpm_error(xpm, WX_XPM_FREE_KEYWORD, i));
		wx_buffer_copy(xpm->key[i].keyword, pc->p, xpm->keyword_length);
		pc->p += xpm->keyword_length;
		if (!wx_parse_keyword(pc, " c #")
			|| !zz_parse_hexa(pc, &xpm->key[i].color)
			|| !wx_parse_keyword(pc, "\",\n"))
			return (zz_parse_xpm_error(xpm, WX_XPM_FREE_KEYWORD, i));
		if (i < xpm->color_count - 1 && !wx_parse_keyword(pc, "\""))
			return (zz_parse_xpm_error(xpm, WX_XPM_FREE_KEYWORD, i));
		i++;
	}
	wx_parse_xpm_comment(pc);
	return (wx_true);
}

t_bool	zz_parse_info_h(t_xpm *xpm, t_parse_context *pc)
{
	t_f32	info[4];

	wx_buffer_set(info, sizeof(t_f32), 0);
	if (wx_parse_f32(pc, &info[0])
		&& wx_parse_whitespace(pc)
		&& wx_parse_f32(pc, &info[1])
		&& wx_parse_whitespace(pc)
		&& wx_parse_f32(pc, &info[2])
		&& wx_parse_whitespace(pc)
		&& wx_parse_f32(pc, &info[3])
		&& wx_parse_keyword(pc, "\",\n"))
	{
		xpm->width = (int)info[0];
		xpm->height = (int)info[1];
		xpm->color_count = (int)info[2];
		xpm->keyword_length = (int)info[3];
		xpm->table_size = xpm->color_count * 2;
		xpm->table
			= (t_key_value *)malloc(sizeof(t_key_value) * xpm->table_size );
		if (!xpm->table)
			return (wx_false);
		wx_buffer_set(xpm->table, sizeof(t_key_value) * xpm->table_size , 0);
		return (wx_true);
	}
	return (wx_false);
}

/* Old version.
******************************************************************************************
*/

t_bool	zz_parse_info(t_xpmtest *xpm, t_parse_context *pc)
{
	t_f32	info[4];

	wx_buffer_set(info, sizeof(t_f32), 0);
	if (wx_parse_f32(pc, &info[0])
		&& wx_parse_whitespace(pc)
		&& wx_parse_f32(pc, &info[1])
		&& wx_parse_whitespace(pc)
		&& wx_parse_f32(pc, &info[2])
		&& wx_parse_whitespace(pc)
		&& wx_parse_f32(pc, &info[3])
		&& wx_parse_keyword(pc, "\",\n"))
	{
		xpm->width = (int)info[0];
		xpm->height = (int)info[1];
		xpm->color_count = (int)info[2];
		xpm->keyword_length = (int)info[3];
		xpm->key
			= (t_color_key *)malloc(sizeof(t_color_key) * xpm->color_count);
		if (!xpm->key)
			return (wx_false);
		return (wx_true);
	}
	return (wx_false);
}

/*
** Old version. Parse declaration and possible comments. 
******************************************************************************************
*/

static t_bool	zz_parse_declaration(t_parse_context *pc)
{
	if (wx_parse_keyword(pc, "static")
		&& wx_parse_whitespace(pc)
		&& wx_parse_keyword(pc, "char")
		&& wx_parse_whitespace(pc)
		&& wx_parse_keyword(pc, "*")
		&& wx_parse_until(pc, '{')
		&& wx_parse_whitespace(pc))
	{
		wx_parse_xpm_comment(pc);
		wx_parse_whitespace(pc);
		wx_parse_xpm_comment(pc);
		if (!wx_parse_keyword(pc, "\""))
			return (wx_false);
		return (wx_true);
	}
	return (wx_false);
}

static t_bool	zz_free_txt(t_c8s *txt)
{
	free(txt->buffer);
	txt->buffer = WX_NULL;
	return (wx_false);
}

int main(void)
{
	t_xpmtest		xpm;
	t_xpm			xpm_h;
	t_parse_context	pc;
	t_c8s			txt;

	if (!wx_c8s_new_from_file(&txt, 1024, "data/test_letter.xpm"))
		return (wx_false);
	pc.p = (char const *)txt.buffer;
	pc.e = (char const *)(txt.buffer + txt.size);
	if ((wx_parse_keyword(&pc, "/* XPM */\n")))
	{
		if (!zz_parse_declaration(&pc))
			return (zz_free_txt(&txt));
		write(1, "loading texture...", 19);
		{
			clock_t begin = clock();
			zz_parse_info(&xpm, &pc);
			zz_parse_xpm_colors(&xpm, &pc);
			clock_t end = clock();
			double time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
			printf("time colors %f\n", time_spent);
		}
		{
			clock_t begin = clock();
			zz_parse_xpm_pixels(&xpm, &pc);//***********************************************
			clock_t end = clock();
			double time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
			printf("time pixels array %f\n", time_spent);
		}
		zz_free_txt(&txt);
	// if (!wx_c8s_new_from_file(&txt, 1024, "data/test_comments.xpm"))
	if (!wx_c8s_new_from_file(&txt, 1024, "data/test_letter.xpm"))
		return (wx_false);
	pc.p = (char const *)txt.buffer;
	pc.e = (char const *)(txt.buffer + txt.size);
	if ((wx_parse_keyword(&pc, "/* XPM */\n")))
	{
		if (!zz_parse_declaration(&pc)
			|| !zz_parse_info_h (&xpm_h,&pc)
			|| !wx_parse_xpm_colors(&pc, &xpm_h))
		{
			return (zz_free_txt(&txt));
		}
		write(1, "loading texture...HHH\n", 23);
		{
			clock_t begin = clock();
			if (!wx_parse_xpm_pixels(&pc, &xpm_h) || pc.p != pc.e)
			{
				return (zz_free_txt(&txt));
			}
			clock_t end = clock();
			double time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
			printf("time ht %f\n", time_spent);
		}
	}
	zz_free_txt(&txt);
	unsigned int j = 0;
	while (j < xpm.height * xpm.width)
	{
		if (xpm.pixels[j] != xpm_h.pixels[j])
		{
			printf("index %d diff\n", j);
			break ;
		}
		j++;
	}
	return (0);
	}
}
